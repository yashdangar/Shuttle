<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Google Maps APIs Test</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
          Cantarell, sans-serif;
        background: #f5f5f5;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      h1 {
        color: #333;
        margin-bottom: 30px;
        text-align: center;
      }

      .test-section {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .test-section h2 {
        color: #1976d2;
        margin-bottom: 15px;
        font-size: 18px;
      }

      .status {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
        margin-left: 10px;
      }

      .status.success {
        background: #4caf50;
        color: white;
      }

      .status.error {
        background: #f44336;
        color: white;
      }

      .status.pending {
        background: #ff9800;
        color: white;
      }

      #map {
        width: 100%;
        height: 400px;
        border-radius: 8px;
        margin-top: 10px;
      }

      .input-group {
        margin: 15px 0;
      }

      .input-group label {
        display: block;
        margin-bottom: 5px;
        color: #666;
        font-size: 14px;
      }

      .input-group input {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
      }

      .button-group {
        margin: 15px 0;
      }

      button {
        background: #1976d2;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        margin-right: 10px;
        margin-bottom: 10px;
      }

      button:hover {
        background: #1565c0;
      }

      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .result-box {
        background: #f9f9f9;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 15px;
        margin-top: 15px;
        font-size: 13px;
        max-height: 200px;
        overflow-y: auto;
      }

      .result-box pre {
        white-space: pre-wrap;
        word-wrap: break-word;
        font-family: "Courier New", monospace;
      }

      .error-message {
        color: #f44336;
        margin-top: 10px;
        font-size: 13px;
      }

      .success-message {
        color: #4caf50;
        margin-top: 10px;
        font-size: 13px;
      }

      .api-key-display {
        background: #fff3cd;
        border: 1px solid #ffc107;
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 20px;
        font-size: 12px;
        word-break: break-all;
      }

      /* Google Maps Autocomplete Dropdown Styling */
      .pac-container {
        z-index: 9999 !important;
        border-radius: 4px;
        border: 1px solid #ddd;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        margin-top: 2px;
        background: white;
      }

      .pac-item {
        padding: 10px 12px;
        cursor: pointer;
        border-top: 1px solid #e6e6e6;
        font-size: 14px;
      }

      .pac-item:first-child {
        border-top: none;
      }

      .pac-item:hover {
        background-color: #f5f5f5;
      }

      .pac-item-selected {
        background-color: #e3f2fd !important;
      }

      .pac-icon {
        margin-right: 8px;
      }

      .pac-matched {
        font-weight: 600;
      }

      .input-group {
        position: relative;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Google Maps APIs Test Suite</h1>

      <div class="api-key-display">
        <strong>API Key:</strong> <span id="apiKeyDisplay"></span>
      </div>

      <!-- Maps JavaScript API Test -->
      <div class="test-section">
        <h2>
          Maps JavaScript API
          <span class="status pending" id="mapsJsStatus">Testing...</span>
        </h2>
        <div id="map"></div>
      </div>

      <!-- Places API (Autocomplete) Test -->
      <div class="test-section">
        <h2>
          Places API (Autocomplete)
          <span class="status pending" id="placesAutocompleteStatus"
            >Testing...</span
          >
        </h2>
        <div class="input-group">
          <label>Search for a place:</label>
          <input
            type="text"
            id="autocomplete"
            placeholder="Type a location..."
          />
        </div>
        <div class="result-box" id="autocompleteResult" style="display: none">
          <pre id="autocompleteResultContent"></pre>
        </div>
      </div>

      <!-- Places API (New) Test -->
      <div class="test-section">
        <h2>
          Places API (New)
          <span class="status pending" id="placesNewStatus">Testing...</span>
        </h2>
        <div class="input-group">
          <label>Place ID to test (get from autocomplete above):</label>
          <input type="text" id="placeIdInput" placeholder="Enter a Place ID" />
        </div>
        <div class="button-group">
          <button onclick="testPlacesNew()">Test Places API (New)</button>
        </div>
        <div class="result-box" id="placesNewResult" style="display: none">
          <pre id="placesNewResultContent"></pre>
        </div>
      </div>

      <!-- Geocoding API Test -->
      <div class="test-section">
        <h2>
          Geocoding API
          <span class="status pending" id="geocodingStatus">Testing...</span>
        </h2>
        <div class="input-group">
          <label>Address to geocode:</label>
          <input
            type="text"
            id="geocodeInput"
            placeholder="Enter an address"
            value="1600 Amphitheatre Parkway, Mountain View, CA"
          />
        </div>
        <div class="button-group">
          <button onclick="testGeocoding()">Geocode Address</button>
          <button onclick="testReverseGeocoding()">
            Test Reverse Geocoding
          </button>
        </div>
        <div class="result-box" id="geocodingResult" style="display: none">
          <pre id="geocodingResultContent"></pre>
        </div>
      </div>

      <!-- Routes API Test -->
      <div class="test-section">
        <h2>
          Routes API
          <span class="status pending" id="routesStatus">Testing...</span>
        </h2>
        <div class="input-group">
          <label>Origin:</label>
          <input
            type="text"
            id="routeOrigin"
            placeholder="Origin address"
            value="New York, NY"
          />
        </div>
        <div class="input-group">
          <label>Destination:</label>
          <input
            type="text"
            id="routeDestination"
            placeholder="Destination address"
            value="Los Angeles, CA"
          />
        </div>
        <div class="button-group">
          <button onclick="testRoutesAPI()">Get Route</button>
        </div>
        <div class="result-box" id="routesResult" style="display: none">
          <pre id="routesResultContent"></pre>
        </div>
      </div>

      <!-- Geolocation API Test -->
      <div class="test-section">
        <h2>
          Geolocation API
          <span class="status pending" id="geolocationStatus">Testing...</span>
        </h2>
        <div class="button-group">
          <button onclick="testGeolocationAPI()">Test Geolocation API</button>
        </div>
        <div class="result-box" id="geolocationResult" style="display: none">
          <pre id="geolocationResultContent"></pre>
        </div>
      </div>
    </div>

    <script>
      const API_KEY = "AIzaSyDbZieANDHL9LrJlsVY5c_UQCKE9MP-Y_E";
      let map;
      let autocomplete;
      let geocoder;

      // Display API key
      document.getElementById("apiKeyDisplay").textContent = API_KEY;

      // Initialize Maps JavaScript API
      function initMap() {
        try {
          map = new google.maps.Map(document.getElementById("map"), {
            center: { lat: 37.7749, lng: -122.4194 },
            zoom: 12,
          });

          // Add a marker
          new google.maps.Marker({
            position: { lat: 37.7749, lng: -122.4194 },
            map: map,
            title: "Test Marker",
          });

          updateStatus("mapsJsStatus", "success", "Working");
        } catch (error) {
          updateStatus("mapsJsStatus", "error", "Failed");
          console.error("Maps JavaScript API Error:", error);
        }
      }

      // Initialize Places Autocomplete
      function initAutocomplete() {
        try {
          const input = document.getElementById("autocomplete");
          autocomplete = new google.maps.places.Autocomplete(input, {
            types: ["establishment", "geocode"],
          });

          autocomplete.addListener("place_changed", () => {
            const place = autocomplete.getPlace();
            if (place.geometry) {
              updateStatus("placesAutocompleteStatus", "success", "Working");
              document.getElementById("autocompleteResult").style.display =
                "block";
              document.getElementById("autocompleteResultContent").textContent =
                JSON.stringify(place, null, 2);

              // Update map to show selected place
              if (map) {
                map.setCenter(place.geometry.location);
                map.setZoom(15);
                new google.maps.Marker({
                  position: place.geometry.location,
                  map: map,
                  title: place.name,
                });
              }

              // Fill place ID input for Places API (New) test
              if (place.place_id) {
                document.getElementById("placeIdInput").value = place.place_id;
              }
            } else {
              updateStatus("placesAutocompleteStatus", "error", "Failed");
            }
          });

          updateStatus("placesAutocompleteStatus", "success", "Ready");
        } catch (error) {
          updateStatus("placesAutocompleteStatus", "error", "Failed");
          console.error("Places Autocomplete Error:", error);
        }
      }

      // Test Places API (New)
      async function testPlacesNew() {
        const placeId = document.getElementById("placeIdInput").value;
        if (!placeId) {
          alert(
            "Please enter a Place ID or select a place from autocomplete first"
          );
          return;
        }

        try {
          updateStatus("placesNewStatus", "pending", "Testing...");
          const service = new google.maps.places.PlacesService(map);

          service.getDetails(
            {
              placeId: placeId,
              fields: [
                "name",
                "formatted_address",
                "geometry",
                "rating",
                "types",
                "place_id",
              ],
            },
            (place, status) => {
              if (status === google.maps.places.PlacesServiceStatus.OK) {
                updateStatus("placesNewStatus", "success", "Working");
                document.getElementById("placesNewResult").style.display =
                  "block";
                document.getElementById("placesNewResultContent").textContent =
                  JSON.stringify(place, null, 2);
              } else {
                updateStatus("placesNewStatus", "error", "Failed: " + status);
                document.getElementById("placesNewResult").style.display =
                  "block";
                document.getElementById("placesNewResultContent").textContent =
                  "Error: " + status;
              }
            }
          );
        } catch (error) {
          updateStatus("placesNewStatus", "error", "Failed");
          document.getElementById("placesNewResult").style.display = "block";
          document.getElementById("placesNewResultContent").textContent =
            "Error: " + error.message;
        }
      }

      // Test Geocoding API
      async function testGeocoding() {
        const address = document.getElementById("geocodeInput").value;
        if (!address) {
          alert("Please enter an address");
          return;
        }

        try {
          updateStatus("geocodingStatus", "pending", "Testing...");
          if (!geocoder) {
            geocoder = new google.maps.Geocoder();
          }

          geocoder.geocode({ address: address }, (results, status) => {
            if (status === "OK") {
              updateStatus("geocodingStatus", "success", "Working");
              document.getElementById("geocodingResult").style.display =
                "block";
              document.getElementById("geocodingResultContent").textContent =
                JSON.stringify(results, null, 2);

              if (results[0] && map) {
                map.setCenter(results[0].geometry.location);
                map.setZoom(15);
                new google.maps.Marker({
                  position: results[0].geometry.location,
                  map: map,
                  title: results[0].formatted_address,
                });
              }
            } else {
              updateStatus("geocodingStatus", "error", "Failed: " + status);
              document.getElementById("geocodingResult").style.display =
                "block";
              document.getElementById("geocodingResultContent").textContent =
                "Error: " + status;
            }
          });
        } catch (error) {
          updateStatus("geocodingStatus", "error", "Failed");
          document.getElementById("geocodingResult").style.display = "block";
          document.getElementById("geocodingResultContent").textContent =
            "Error: " + error.message;
        }
      }

      // Test Reverse Geocoding
      async function testReverseGeocoding() {
        try {
          updateStatus("geocodingStatus", "pending", "Testing...");
          if (!geocoder) {
            geocoder = new google.maps.Geocoder();
          }

          // Use a test location (San Francisco)
          const latlng = { lat: 37.7749, lng: -122.4194 };
          geocoder.geocode({ location: latlng }, (results, status) => {
            if (status === "OK") {
              updateStatus("geocodingStatus", "success", "Working");
              document.getElementById("geocodingResult").style.display =
                "block";
              document.getElementById("geocodingResultContent").textContent =
                "Reverse Geocoding Result:\n\n" +
                JSON.stringify(results, null, 2);
            } else {
              updateStatus("geocodingStatus", "error", "Failed: " + status);
              document.getElementById("geocodingResult").style.display =
                "block";
              document.getElementById("geocodingResultContent").textContent =
                "Error: " + status;
            }
          });
        } catch (error) {
          updateStatus("geocodingStatus", "error", "Failed");
          document.getElementById("geocodingResult").style.display = "block";
          document.getElementById("geocodingResultContent").textContent =
            "Error: " + error.message;
        }
      }

      // Test Routes API (using new Routes API)
      async function testRoutesAPI() {
        const origin = document.getElementById("routeOrigin").value;
        const destination = document.getElementById("routeDestination").value;

        if (!origin || !destination) {
          alert("Please enter both origin and destination");
          return;
        }

        try {
          updateStatus("routesStatus", "pending", "Testing...");

          // First, geocode the origin and destination to get coordinates
          if (!geocoder) {
            geocoder = new google.maps.Geocoder();
          }

          // Geocode origin
          const originGeocode = await new Promise((resolve, reject) => {
            geocoder.geocode({ address: origin }, (results, status) => {
              if (status === "OK" && results[0]) {
                resolve(results[0].geometry.location);
              } else {
                reject(new Error("Failed to geocode origin: " + status));
              }
            });
          });

          // Geocode destination
          const destGeocode = await new Promise((resolve, reject) => {
            geocoder.geocode({ address: destination }, (results, status) => {
              if (status === "OK" && results[0]) {
                resolve(results[0].geometry.location);
              } else {
                reject(new Error("Failed to geocode destination: " + status));
              }
            });
          });

          // Call the new Routes API
          const response = await fetch(
            `https://routes.googleapis.com/directions/v2:computeRoutes`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-Goog-Api-Key": API_KEY,
                "X-Goog-FieldMask":
                  "routes.duration,routes.distanceMeters,routes.polyline,routes.legs",
              },
              body: JSON.stringify({
                origin: {
                  location: {
                    latLng: {
                      latitude: originGeocode.lat(),
                      longitude: originGeocode.lng(),
                    },
                  },
                },
                destination: {
                  location: {
                    latLng: {
                      latitude: destGeocode.lat(),
                      longitude: destGeocode.lng(),
                    },
                  },
                },
                travelMode: "DRIVE",
                routingPreference: "TRAFFIC_AWARE",
                computeAlternativeRoutes: false,
                routeModifiers: {
                  avoidTolls: false,
                  avoidHighways: false,
                  avoidFerries: false,
                },
                languageCode: "en-US",
                units: "IMPERIAL",
              }),
            }
          );

          const data = await response.json();
          console.log("Routes API Response:", data);

          if (response.ok && data.routes && data.routes.length > 0) {
            const route = data.routes[0];

            // Parse duration - Routes API returns duration as object with seconds
            let durationValue = 0;
            if (route.duration) {
              if (typeof route.duration === "string") {
                durationValue = parseInt(route.duration.replace("s", ""));
              } else if (route.duration.seconds) {
                durationValue = parseInt(route.duration.seconds);
              } else if (typeof route.duration === "number") {
                durationValue = route.duration;
              }
            }

            const hours = Math.floor(durationValue / 3600);
            const minutes = Math.floor((durationValue % 3600) / 60);
            const durationText =
              hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
            const distanceMiles = route.distanceMeters
              ? (route.distanceMeters / 1609.34).toFixed(2)
              : "N/A";

            updateStatus("routesStatus", "success", "Working - See map above!");
            document.getElementById("routesResult").style.display = "block";
            document.getElementById("routesResultContent").textContent =
              `Route Found!\n\n` +
              `Distance: ${distanceMiles} miles\n` +
              `Duration: ${durationText}\n` +
              `Origin: ${origin}\n` +
              `Destination: ${destination}\n\n` +
              `ðŸ‘† Look at the map above to see the route visualization!\n\n` +
              `Full API Response:\n` +
              JSON.stringify(route, null, 2);

            // Clear previous route markers and polylines
            if (window.routeMarkers) {
              window.routeMarkers.forEach((marker) => marker.setMap(null));
            }
            if (window.routePolyline) {
              window.routePolyline.setMap(null);
            }
            window.routeMarkers = [];
            window.routePolyline = null;

            // Decode and display the route on the map
            if (map) {
              // Add markers for origin and destination first
              const originMarker = new google.maps.Marker({
                position: originGeocode,
                map: map,
                title: "Origin: " + origin,
                label: {
                  text: "O",
                  color: "white",
                  fontWeight: "bold",
                },
                icon: {
                  path: google.maps.SymbolPath.CIRCLE,
                  scale: 10,
                  fillColor: "#4caf50",
                  fillOpacity: 1,
                  strokeColor: "#fff",
                  strokeWeight: 2,
                },
              });

              const destMarker = new google.maps.Marker({
                position: destGeocode,
                map: map,
                title: "Destination: " + destination,
                label: {
                  text: "D",
                  color: "white",
                  fontWeight: "bold",
                },
                icon: {
                  path: google.maps.SymbolPath.CIRCLE,
                  scale: 10,
                  fillColor: "#f44336",
                  fillOpacity: 1,
                  strokeColor: "#fff",
                  strokeWeight: 2,
                },
              });

              window.routeMarkers.push(originMarker, destMarker);

              // Decode and display polyline if available
              // Routes API can return polyline in different formats (route.polyline or route.legs[].polyline)
              let polylineString = null;

              // Check route-level polyline first
              if (route.polyline) {
                if (typeof route.polyline === "string") {
                  polylineString = route.polyline;
                } else if (route.polyline.encodedPolyline) {
                  polylineString = route.polyline.encodedPolyline;
                }
              }

              // If not found, check legs
              if (!polylineString && route.legs && route.legs.length > 0) {
                // Combine polylines from all legs
                const legPolylines = route.legs
                  .map((leg) => {
                    if (leg.polyline) {
                      return typeof leg.polyline === "string"
                        ? leg.polyline
                        : leg.polyline.encodedPolyline;
                    }
                    return null;
                  })
                  .filter((p) => p !== null);

                if (legPolylines.length > 0) {
                  // For now, use the first leg's polyline (or we could combine them)
                  polylineString = legPolylines[0];
                }
              }

              if (
                polylineString &&
                google.maps.geometry &&
                google.maps.geometry.encoding
              ) {
                try {
                  const decodedPath =
                    google.maps.geometry.encoding.decodePath(polylineString);
                  window.routePolyline = new google.maps.Polyline({
                    path: decodedPath,
                    geodesic: true,
                    strokeColor: "#1976d2",
                    strokeOpacity: 1.0,
                    strokeWeight: 5,
                  });
                  window.routePolyline.setMap(map);

                  // Fit bounds to show the entire route
                  const bounds = new google.maps.LatLngBounds();
                  decodedPath.forEach((point) => bounds.extend(point));
                  bounds.extend(originGeocode);
                  bounds.extend(destGeocode);
                  map.fitBounds(bounds);

                  // Scroll to map
                  document
                    .getElementById("map")
                    .scrollIntoView({ behavior: "smooth", block: "center" });
                } catch (polylineError) {
                  console.error(
                    "Error decoding polyline:",
                    polylineError,
                    "Polyline string:",
                    polylineString
                  );
                  // Fallback: draw a simple line between origin and destination
                  window.routePolyline = new google.maps.Polyline({
                    path: [originGeocode, destGeocode],
                    geodesic: true,
                    strokeColor: "#1976d2",
                    strokeOpacity: 0.8,
                    strokeWeight: 4,
                  });
                  window.routePolyline.setMap(map);

                  const bounds = new google.maps.LatLngBounds();
                  bounds.extend(originGeocode);
                  bounds.extend(destGeocode);
                  map.fitBounds(bounds);

                  // Scroll to map
                  document
                    .getElementById("map")
                    .scrollIntoView({ behavior: "smooth", block: "center" });
                }
              } else {
                // If no polyline, draw a simple line between points
                console.log(
                  "No polyline found, drawing straight line. Route data:",
                  route
                );
                window.routePolyline = new google.maps.Polyline({
                  path: [originGeocode, destGeocode],
                  geodesic: true,
                  strokeColor: "#1976d2",
                  strokeOpacity: 0.8,
                  strokeWeight: 4,
                });
                window.routePolyline.setMap(map);

                const bounds = new google.maps.LatLngBounds();
                bounds.extend(originGeocode);
                bounds.extend(destGeocode);
                map.fitBounds(bounds);

                // Scroll to map
                document
                  .getElementById("map")
                  .scrollIntoView({ behavior: "smooth", block: "center" });
              }
            }
          } else {
            updateStatus("routesStatus", "error", "Failed");
            document.getElementById("routesResult").style.display = "block";
            document.getElementById("routesResultContent").textContent =
              "Error: " + JSON.stringify(data, null, 2);
          }
        } catch (error) {
          updateStatus("routesStatus", "error", "Failed");
          document.getElementById("routesResult").style.display = "block";
          document.getElementById("routesResultContent").textContent =
            "Error: " + error.message;
        }
      }

      // Test Geolocation API (server-side style)
      async function testGeolocationAPI() {
        try {
          updateStatus("geolocationStatus", "pending", "Testing...");

          // Test using browser's geolocation API first
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              async (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;

                // Now test Google's Geolocation API via fetch
                const response = await fetch(
                  `https://www.googleapis.com/geolocation/v1/geolocate?key=${API_KEY}`,
                  {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                      considerIp: true,
                    }),
                  }
                );

                const data = await response.json();

                if (response.ok) {
                  updateStatus("geolocationStatus", "success", "Working");
                  document.getElementById("geolocationResult").style.display =
                    "block";
                  document.getElementById(
                    "geolocationResultContent"
                  ).textContent = JSON.stringify(
                    {
                      browser_location: { lat, lng },
                      google_api_result: data,
                    },
                    null,
                    2
                  );
                } else {
                  updateStatus("geolocationStatus", "error", "Failed");
                  document.getElementById("geolocationResult").style.display =
                    "block";
                  document.getElementById(
                    "geolocationResultContent"
                  ).textContent = "Error: " + JSON.stringify(data, null, 2);
                }
              },
              (error) => {
                updateStatus(
                  "geolocationStatus",
                  "error",
                  "Browser Geolocation Failed"
                );
                document.getElementById("geolocationResult").style.display =
                  "block";
                document.getElementById(
                  "geolocationResultContent"
                ).textContent = "Browser Geolocation Error: " + error.message;
              }
            );
          } else {
            // Fallback: test Google Geolocation API directly
            const response = await fetch(
              `https://www.googleapis.com/geolocation/v1/geolocate?key=${API_KEY}`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  considerIp: true,
                }),
              }
            );

            const data = await response.json();

            if (response.ok) {
              updateStatus("geolocationStatus", "success", "Working");
              document.getElementById("geolocationResult").style.display =
                "block";
              document.getElementById("geolocationResultContent").textContent =
                JSON.stringify(data, null, 2);
            } else {
              updateStatus("geolocationStatus", "error", "Failed");
              document.getElementById("geolocationResult").style.display =
                "block";
              document.getElementById("geolocationResultContent").textContent =
                "Error: " + JSON.stringify(data, null, 2);
            }
          }
        } catch (error) {
          updateStatus("geolocationStatus", "error", "Failed");
          document.getElementById("geolocationResult").style.display = "block";
          document.getElementById("geolocationResultContent").textContent =
            "Error: " + error.message;
        }
      }

      function updateStatus(elementId, status, text) {
        const element = document.getElementById(elementId);
        element.className = "status " + status;
        element.textContent = text;
      }

      // Load Google Maps script
      window.initMap = initMap;
      window.initAutocomplete = initAutocomplete;

      const script = document.createElement("script");
      script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&libraries=places,geometry&callback=initMapAndAutocomplete`;
      script.async = true;
      script.defer = true;

      function initMapAndAutocomplete() {
        initMap();
        initAutocomplete();
      }

      script.onerror = () => {
        updateStatus("mapsJsStatus", "error", "Script Load Failed");
        console.error("Failed to load Google Maps script");
      };

      document.head.appendChild(script);
    </script>
  </body>
</html>
